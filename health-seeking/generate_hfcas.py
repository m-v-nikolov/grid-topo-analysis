# -*- coding: utf-8 -*- 

# if not happy with utf-8 feel free to edit the comments below for non-ascii characters that break python's bytecode compiler


'''
Generate health facility catchment areas, in our case over a grid topology, following a sample basic logic of health-seeking
https://wiki.idmod.org/display/EMOD/2017/02/13/Haiti%3A+gridded+households+topology+analysis

Health seeking protocol

Given a "natural" population clustering (e.g. based on roads, geo topography, cities, geo distance) each grid-cell is labeled/colored by the cluster it belongs to. 
Upon getting sick, each simulated individual in a grid cell follows roughly the following protocol:
    if one or more HFs are in my cluster x, pick a HF to visit drawn from a probability distribution favoring HFs closer (in Manhattan distance) to me and with higher population cell-neighborhoods in x;
    if no HFs are in my cluster x:
        count the number of distinct cluster labels of grid-cells along the shortest Manhattan paths to all available HFs in clusters other than x;
        pick the HF i connected to me via the path with fewest distinct labels l (e.g. due to the properties of our agglomerative clustering, fewer labels corresponds to less topography variation on the way, which may account for preferring to not go over hills/mountains/valleys, etc. multiple times). In case of a tie, pick a HF i following a probability distribution favoring HFs in higher density cell-neighborhoods and shorter Manhattan distances away from me;
    if l < t select HF i picked at the previous step; else drop i and pick the nearest HF (in Manhattan distance) from the top k facilities in my province, where each HF is ranked by total population in cells neighboring the HF (including the one the HF is in). The latter step indicates that once I were to travel a long distance to a HF, I'd be willing to travel a bit longer to at least get to a HF that's potentially better – using population density as a proxy for higher likelihood that the HF is not poorly-stocked dispensary)

Once I picked HF i to visit for my clinical episode treatment, I determine the probability with which I will actually access care. 
(The logic for that is in generate_health_seeking_rates.py) 
The probability follows a power law on the Euclidean distance from a source grid cell to HF i. We pick a power law exponent of around 2, 
which has been shown in the past to model well various human and animal exploration activities, and models well the distribution of road lengths in various countries.


The health seeking protocol parameters above tend to favor ease of travel by foot, preferably to facilities in higher population density areas (cities/towns) – as a proxy for quality – over exclusively 
traveling to closer facilities “as the crow flies”. Since the protocol is probabilistic, each grid-cell population is potentially serviced by multiple HFs; 
furthermore, the same individuals in each grid cell might decide to go to different HFs over multiple clinical episodes. 
Changing the parameters of the model could collapse it to special cases with different properties.

- input:      - json grid topo graph adjacency list (e.g. gridded_households_adj_list.json as generated by ../build-grid-topo/build_grid_topo.py or build_grid_topo_w_hospitals.py) 
              - csv grid topo cells labeled by clusters w/ required columns node_label,lon,lat,pop,cluster_label (e.g. grid_cluster_labels.csv generated by ../cluster-grid-topo/cluster_grid_cells.py)
              - health facility locations on the grid w/ requried columns 'lon', 'lat', 'node_label' where node_label indicates the grid cell the health facility is in (e.g. hospitals_node_labeled.csv as generated by ../build-grid-topo/build_grid_topo_w_hospitals.py) 
              
- output:     - shortest paths between each grid cells and all reachable health facilities (shortest_paths_cells_2_hfs.json for paths and shortest_paths_cells_lens_2_hfs.json for lengths)
              - health facility catchment area network (hfs_network_node_link.json and  hfs_network_adjacency_data.json different representations of the network that may be useful for different types of visualization/postprocessing, etc.)
              
              
Note: the parameter values used throughout the script for the example geography/clustering do not necessarily result in the most reasonable health facility catchment areas   
'''

import pandas as pd
import json
import numpy as np
import random
import os

import matplotlib.pyplot as plt

import networkx as nx
from networkx.readwrite import json_graph
from networkx.utils import generate_unique_node


# not currently used but left for reference if needed
def all_sources_shortest_paths_to_dests(G, dsts):
    
    """
    :param G: networkx graph
    :param dsts: list of destination nodes in the graph; subset of all nodes
    """
    
    path = nx.single_source_dijkstra_path
    paths = {n: path(G, n, cutoff=None, weight="weight") for n in dsts}

    #reverse paths so they go from a source to the target.
    dst_srcs_to_dsts = {}
    for dst in dsts:
        dst_srcs_to_dsts[dst] = {}
        for dst in paths:
            dst_src_to_dsts[dst] = list(reversed(paths[dst]))
    
    return dst_srcs_to_dsts
                



def plot_network(graph):
    
    """
    :param graph: networkx graph
    """
    
    pos = {}
    node_sizes = []
    max_marker = 400 

    # following loops are not most efficient given networx graph data struct
    
    # find max pop
    max_pop = 0.0
    for i, node_id in enumerate(graph.nodes(data = False)):
        pop = graph.population[node_id]
        if pop > max_pop:
            max_pop = pop
    
    # calculate node sizes for figure
    for i, node_id in enumerate(graph.nodes(data = False)):
        pos[node_id] = graph.position[node_id] # assume a graph topo has nodes positions and populations
        node_sizes.append(max_marker*graph.population[node_id]/max_pop)   
    
    nx.draw_networkx(graph, pos, with_labels = False, node_size = node_sizes, alpha = 0.75, node_color = 'blue')
    
    plt.show()
    

# just a modified version of plot_network
def plot_hfca_network(graph):
    
    """
    :param graph: networkx graph
    """
    pos = {}
    node_sizes = []
    max_marker = 400 

    # following loops are not most efficient given networx graph data struct
    
    # find max pop
    max_pop = 0.0
    for i, node_id in enumerate(graph.nodes(data = False)):
        pop = graph.population[node_id]
        if pop > max_pop:
            max_pop = pop
    
    # calculate node sizes for figure
    for i, node_id in enumerate(graph.nodes(data = False)):
        pos[node_id] = graph.position[node_id] # assume a graph topo has nodes positions and populations
        node_sizes.append(max_marker*graph.population[node_id]/max_pop)   
    
    nx.draw_networkx(graph, pos, with_labels = False, node_size = node_sizes, alpha = 0.75, node_color = 'blue', arrows = True)
    
    plt.show()


'''
given 
- the shortest paths and the distance between grid cells and health facilities, 
- the population density of the neighborhood cells containing the health facility

simplistic calculation of preference weight for (health facility, grid cell) pair (i, x). The function is called for each grid cell x.
I.e. the higher the weight of (i, x), the more likely the individual in cell x is to seek care at health facility i.

Note that some HFs may not be reachable by some grid cells if the topology grid contains multiple connected components.    
'''
def get_hf_cost_benefit_weights(hfs_node_labels, shortest_paths_to_hfs, hfs_neighborhood_pop):
    
    """
    :param hfs_node_labels: health facilities set to which individuals from grid cell x may seek care
    :param shortest_paths_to_hfs: length of shortest path between grid cell x and each health facility in the HF set 
    :param hfs_neighborhood_pop: population of the neighborhood in each HF set
    """
    
    cost_benefit_weights = {}
    
    # find total population in hf neighborhood and total grid cell to health facility distances
    pop_tot = 0.0
    dist_tot = 0.0 
    for hfs_node_label in hfs_node_labels:
        if hfs_node_label in hfs_neighborhood_pop and hfs_node_label in shortest_paths_to_hfs: 
            pop_tot += hfs_neighborhood_pop[hfs_node_label]
            dist_tot += shortest_paths_to_hfs[hfs_node_label]
    
    
    # handle edge case where the sum of shortest paths is zero; might want to change that
    if dist_tot == 0.0:
        dist_tot = 0.25
        
    # find cumulative normalized pop weight to dist weight ratio
    # notice that the higher the ratio the more dense and/or closer the cell is relative to other cells 
    # (i.e. intended rationale: if distance is the price to get to a more populous cell, minimize the price for maximum payoff)
    pop_dist_ratio_tot = 0.0
    for hfs_node_label in hfs_node_labels:
        if hfs_node_label in hfs_neighborhood_pop and hfs_node_label in shortest_paths_to_hfs:
           pop_weight =  hfs_neighborhood_pop[hfs_node_label]/(pop_tot + 0.0)
           dist_weight = shortest_paths_to_hfs[hfs_node_label]/(dist_tot + 0.0)
    
           # edge cases where shortest path is 0
           if dist_weight == 0:
               dist_weight = 0.01
               
           pop_dist_ratio_tot += pop_weight/(dist_weight + 0.0)
    
    
    
    # find relative weight of pop/distance ratio for each HF in the cluster; the higher the weight the more likely to seek care in this HF
    # add a link with the relative weight between the source cell and each HF
    for hfs_node_label in hfs_node_labels:
       if hfs_node_label in hfs_neighborhood_pop and hfs_node_label in shortest_paths_to_hfs:
           pop_weight =  hfs_neighborhood_pop[hfs_node_label]/(pop_tot + 0.0)
           dist_weight = shortest_paths_to_hfs[hfs_node_label]/(dist_tot + 0.0)
           
           if dist_weight == 0:
               dist_weight = 0.01
               
           w = (pop_weight/(dist_weight + 0.0))/pop_dist_ratio_tot
           
           cost_benefit_weights[hfs_node_label] = w
       
    return cost_benefit_weights 
    

cluster_transit_threshold = 8 # equivalent to l in the health seeking protocol above; this is very likely geography dependent and may need to be changed
highest_density_cells_num = 5 # how many of the top cells with highest populations to consider; see health seeking protocol above  



with open("gridded_households_adj_list.json", "r") as al_f:
    adjacency_list = json.load(al_f)
    
nodes_records = pd.read_csv("grid_cluster_labels.csv").as_matrix(['node_label', 'lon', 'lat', 'pop', 'cluster_label'])

hf_records = pd.read_csv("hospitals_node_labeled.csv").as_matrix(['lon', 'lat', 'node_label'])

# get all nodes containing a health facility
hf_node_labels = []
for hf_record in hf_records:
    hf_node_labels.append(int(hf_record[2]))

print "Added " + str(len(hf_node_labels)) + " HFs" 



'''
initialize the neworkx graph containgin the grid topo
'''

G=nx.Graph()
G.position={}
G.population={}
G.cluster_label={}
G.name={}
G.node_type={}


# geographical area of interest (useful for plotting)
x_min = -74.339894
x_max = -74.093235
y_min = 18.511138
y_max = 18.597931


# add nodes/cells and cluster labels for each cell 
for node_record in nodes_records:
    node_label = int(node_record[0])
    lon = node_record[1]
    lat = node_record[2]
    pop = node_record[3]
    cluster_label = node_record[4]
    
    
    G.add_node(node_label)
    
    G.name[node_label] = node_label
    G.population[node_label] = pop
    G.position[node_label]=(lon, lat) # (x,y) for matplotlib
    G.cluster_label[node_label] = cluster_label
    
    # check if a node is a hospital
    if node_label in hf_node_labels:
        G.node_type = "hf"
    else:
        G.node_type = "residential"


# get graph nodes
nodes = G.nodes()    

print "Added nodes to graph" 



# add provided local links to graph
for node_label, node_links in adjacency_list.iteritems():
    
    
    # notice that we will sample/sparsify the original graph (as it may be quite dense)
    # by removing edges w/ probability proportional to a node's outdegree (that can be chagned if needed)
    # since we are working with a grid the sampling shouldn't affect connectivity and path lengths too much
    # a more rigorous sampling/sparsification scheme with some guarantees on the resulting subgraph properties is possible, 
    # but for now this should work out reasonably well
    # only subsample if the grid graph is too dense and subsampling is nedeed for performance
       
    if len(node_links) <= 4:
        link_prob = 1.0
    else:
        link_prob = 9/(len(node_links) + 0.0) # determine fraction of links to leave in; one can play with nominator and check the resulting health seeking rates (e.g. see ./hs_rates_no_subsampling.png vs hs_rates_w_subsampling.png; the more similar the better)
        
    
    for node_link_label, w in node_links.iteritems():
        if int(node_label) in nodes and int(node_link_label) in nodes: # only add an edge between existing nodes
            if random.uniform(0,1) < link_prob: # subsample the graph
                G.add_edge(int(node_label), int(node_link_label), weight = w)
                
                
# if there are disconnected ocmponents in the graph as a result of the subsampling or the input topology,
# we can augment the graph by sprinkling a few edges...
ccs = sorted(nx.connected_components(G), key = len, reverse=True)
connected_ccs = []
print "Number CC before augmenting " + str(nx.number_connected_components(G))

print "Augmenting graph to connect components..."

for node_label, node_links in adjacency_list.iteritems():
    src_cc = None
    for i,cc in enumerate(ccs):
        if int(node_label) in cc:
            src_cc = i
            break
    
    for node_link_label, w in node_links.iteritems():
        dst_cc = None
        if int(node_label) in nodes and int(node_link_label) in nodes: # only add an edge between existing nodes
                for j,cc in enumerate(ccs):
                    if int(node_link_label) in cc:
                        dst_cc = j
                        break
                    
                if src_cc != dst_cc and not str(i) + "_" + str(j) in connected_ccs:
                    G.add_edge(int(node_label), int(node_link_label), weight = w)
                    connected_ccs.append(str(i) + "_" + str(j))
                    connected_ccs.append(str(j) + "_" + str(i))
                    print "Added an edge between " + str(i) + " and " + str(j)
    

print "Added links to graph"

print "Number CCs after augmentation " + str(nx.number_connected_components(G))

print "Number of isolated nodes after augmentation " + str(len(nx.isolates(G)))

print "Num. nodes " + str(len(G))
print "Num. edges " + str(G.number_of_edges())

augmented_network_data = json_graph.adjacency_data(G)

# cache the augmented network to avoid recalculating if needed in the future; in case network initialization and augmentation take much time
with open("augmented_network_adjacency_data.json", "w") as nl_f:
    json.dump(augmented_network_data, nl_f)  


# one can inspect the augmented network to check if it appears reasonable 
# notice that for the purposes of health seeking what counts the most (after resampling and augmentation) is
# - whether the HF I could reach in the original network are still reachable
# - whether the path that I'd take on the grid is not much longer/shorter
# the sampling and augmentation steps should produce reasonable networks in that sense, however one might want to adjust those if needed
# easy to automate w/ a script to check how much connectivity and path lengths have changed due to sampling and augmentation  

plot_network(G)


# calcualte shortest paths between each grid cell and available health facilities
# currently networkx doesn't provide a good DP solution for partial transitive closure on graphs
# e.g. in their implementation all pairs shortest paths algorithms are either slow for large networks (flod-warshall) or a vertex by vertex dijkstra, which is again slow for large networks...
# so here we just do sequential vertex by vertex dijkstra; if that's too slow, ask Milen for a faster shortest path implementation that work on networkx graphs
# the current implementation takes about 5 hours to process a graph of ~6k nodes and ~12k edges 
 
shortest_paths_src_hfs = {}
shortest_paths_lens_src_hfs = {}
for i,src_label in enumerate(nodes):
    
    shortest_paths_to_hfs = {}
    shortest_paths_lens_to_hfs = {}
    
    for dst_label in hf_node_labels:
    
        #if the destination node contains a hf find the shortest path between the source cell and the health facility
        try:
            path = nx.shortest_path(G, source = src_label, target = dst_label, weight = "weight")
            shortest_paths_to_hfs[dst_label] = path
            path_weight = 0.0
            for j in range(len(path) - 1):
                path_weight += G.get_edge_data(path[j], path[j+1])['weight'] 

            shortest_paths_lens_to_hfs[dst_label] = path_weight 
            
            '''
            if dst_label == 51:
                print src_label
                print path_weight
                print "========================================="
            '''
            
        except nx.NetworkXNoPath:
            #if dst_label == 51: 
            #    print "No path between node " + str(src_label) + " and " + str(dst_label)
            pass
        
        
    
    shortest_paths_src_hfs[src_label] = shortest_paths_to_hfs
    shortest_paths_lens_src_hfs[src_label] = shortest_paths_lens_to_hfs
    
    if i > 0 and i%10 == 0: 
        print "Processed " + str(len(shortest_paths_src_hfs)) + " nodes"
        

# cache shortest paths to avoid recomputing
with open("shortest_paths_cells_2_hfs.json", "w") as sp_f:
    json.dump(shortest_paths_src_hfs, sp_f)
    
# cache shortest paths lengths to avoid recomputing
with open("shortest_paths_cells_lens_2_hfs.json", "w") as sp_f:
    json.dump(shortest_paths_lens_src_hfs, sp_f, indent = 2)
        

print "Stored paths and lengths to json."



# don't need to re-read paths every time comment out as needed...
with open("shortest_paths_cells_2_hfs.json", "r") as sp_f:
    shortest_paths_src_hfs = json.load(sp_f)
    
with open("shortest_paths_cells_lens_2_hfs.json", "r") as sp_f:
    shortest_paths_lens_src_hfs = json.load(sp_f)



# get population of hf nodes neighborhoods
# might want to get the population from the original graph and not the subsampled and augmented one, depending on edge distribution...
# this is a fast step
hfs_neighborhood_pop = {}
for node_label in hf_node_labels:
    nghbr_pop = 0.0
    if node_label in G.nodes():
        for nghbr_label in G.neighbors(node_label):
            nghbr_pop += G.population[nghbr_label]
    else:
        continue
    
    hfs_neighborhood_pop[node_label] = nghbr_pop 

hfs_nghbr_density_descending = sorted(zip(hfs_neighborhood_pop.keys(), hfs_neighborhood_pop.values()), key=lambda x: x[1], reverse = True)

print "Calculated neighborhood densities for "  + str(len(hfs_nghbr_density_descending)) + " HFs"
 

# node labels of most populous cells
top_hfs_nghbr = [x[0] for x in hfs_nghbr_density_descending[0:highest_density_cells_num]]

print "Found the top " + str(len(top_hfs_nghbr)) + " highest density HFs"



print "Constructing HFCA network..."
nodes_to_hfs_network = nx.DiGraph()
nodes_to_hfs_network.population = {}
nodes_to_hfs_network.position = {}
nodes_to_hfs_network.group = {}

for i,src_label in enumerate(nodes):
        
    # get the cluster label of the source grid cell     
    src_cluster = G.cluster_label[src_label]
    
    nodes_to_hfs_network.add_node(src_label)
    nodes_to_hfs_network.population[src_label] = G.population[src_label]
    nodes_to_hfs_network.position[src_label] = G.position[src_label]
    
    hfs_in_src_cluster = []
    
    # shortest paths originating from this grid cell (i.e. local) to all reachable health facilities 
    local_shortest_paths_lens_src_to_hfs = {}
    local_shortest_paths_src_to_hfs = {}
    
    for dst_label in hf_node_labels:
        if str(src_label) in shortest_paths_lens_src_hfs:
            if str(dst_label) in shortest_paths_lens_src_hfs[str(src_label)]:
                local_shortest_paths_lens_src_to_hfs[dst_label] = shortest_paths_lens_src_hfs[str(src_label)][str(dst_label)]
                local_shortest_paths_src_to_hfs[dst_label] = shortest_paths_src_hfs[str(src_label)][str(dst_label)]
        
        # and get dst hf cluster
        if dst_label in G.cluster_label:
            dst_cluster = G.cluster_label[dst_label]
        else:
            continue
        
        # add the hf to the local cluster hfs if the cluster of the source and destionation match
        if dst_cluster == src_cluster:
            hfs_in_src_cluster.append(dst_label)
    

    # if one or more health facilities in the source cell cluster, 
    # for each facility add an edge to the source cell with weight depending on
    # the src-dst distance and destination population relative to the 
    # populations in the remaining hfs in the cluster

    if len(hfs_in_src_cluster) > 0:  
        
       print "One or more HFs in cluster of node " + str(src_label)
        
       cost_benefit_weights = get_hf_cost_benefit_weights(hfs_in_src_cluster, local_shortest_paths_lens_src_to_hfs, hfs_neighborhood_pop)
    
       for hf_node_label, w in cost_benefit_weights.iteritems():    
           nodes_to_hfs_network.add_node(hf_node_label)
           nodes_to_hfs_network.group[src_label] = hf_node_label
           nodes_to_hfs_network.add_edge(src_label, hf_node_label, weight = w)
           
    else:
        
        #if there is no HF in the source cluster, check if there is a HF around in a radius of cluster_transit_threshold clusters
        print "No HFs in cluster of node " + str(src_label)
        print "Looking for accessible HFs in nearby clusters..."
        
        if local_shortest_paths_src_to_hfs:
           
            hfs_with_min_transit_cluster_num = []
            min_transit_cluster_num = 10000 # to store the minimum number of clusters one would need to traverse to reach a health facility 
            for hfs_node_label, shortest_path in local_shortest_paths_src_to_hfs.iteritems():
                transit_clusters = [] # the set of clusters on a shortest path between the source grid cell and a health facility
                for node_label in shortest_path:
                    cluster_label = G.cluster_label[int(node_label)]
                    if not cluster_label in transit_clusters:
                        transit_clusters.append(cluster_label)
                        
                if len(transit_clusters) < min_transit_cluster_num:
                    hfs_with_min_transit_cluster_num = [hfs_node_label] # hf that's reachable on a path traversing minimum number of clusters
                    min_transit_cluster_num = len(transit_clusters) 
                elif len(transit_clusters) == min_transit_cluster_num:
                    hfs_with_min_transit_cluster_num.append(hfs_node_label) # in case of a tie of transit clusters on a path maintain all tied HFs as potential candidates
                    
            # assign weights to accessible clusters with minimum cluster transit less than the treshold of transit clusters 
            if min_transit_cluster_num <= cluster_transit_threshold:
                print "Found " + str(len(hfs_with_min_transit_cluster_num)) + " nearby HFs for node " + str(src_label)
                cost_benefit_weights = get_hf_cost_benefit_weights(hfs_with_min_transit_cluster_num, local_shortest_paths_lens_src_to_hfs, hfs_neighborhood_pop)
                for hf_node_label, w in cost_benefit_weights.iteritems():    
                       nodes_to_hfs_network.add_node(hf_node_label)
                       nodes_to_hfs_network.group[src_label] = hf_node_label
                       nodes_to_hfs_network.add_edge(src_label, hf_node_label, weight = w)
            # if there are no HFs that don't require crossing too many clusters just pick HFs in the most populated cells
            else: 
                print "Did not find any nearby HFs for node " + str(src_label)
                print "Looking for HFs in most populous areas "
                # select a HF from the top most populous ones
                cost_benefit_weights = get_hf_cost_benefit_weights(top_hfs_nghbr, local_shortest_paths_lens_src_to_hfs, hfs_neighborhood_pop)
                for hf_node_label, w in cost_benefit_weights.iteritems():    
                       nodes_to_hfs_network.add_node(hf_node_label)
                       nodes_to_hfs_network.group[src_label] = hf_node_label
                       nodes_to_hfs_network.add_edge(src_label, hf_node_label, weight = w)
    
    print "Processed " + str(i) + " nodes"

print "Constructed HFCA network"



print "Saving HFCA network"


# get a json orepresentation of the HFCA network along with relevant attributes (e.g. for visualization/postprocessing)
nodes_to_hfs_network_data = json_graph.node_link_data(nodes_to_hfs_network)

hf_2_group = {} 
for node in nodes_to_hfs_network_data["nodes"]:
    node['x'] = (x_max - G.position[node["id"]][0] + 0.0)/(x_max - x_min)
    node['y'] = (y_max - G.position[node["id"]][1] + 0.0)/(y_max - y_min)
    node['lat'] =  G.position[node["id"]][1]
    node['lon'] =  G.position[node["id"]][0]
    node['population'] = G.population[node["id"]]
    if node["id"] in nodes_to_hfs_network.group:
        group = nodes_to_hfs_network.group[node["id"]]
    else:
        continue
    
    
    if not group in hf_2_group:
        hf_2_group[group] = len(hf_2_group)
        node['hf'] = hf_2_group[group]
    else:
        node['hf'] = hf_2_group[group]

for link in nodes_to_hfs_network_data["links"]:
    link['sx'] = (x_max - G.position[link["source"]][0] + 0.0)/(x_max - x_min)
    link['sy'] = (y_max - G.position[link["source"]][1] + 0.0)/(y_max - y_min)
    #link['spop'] = G.population[link["source"]]
    link['tx'] = (x_max - G.position[link["target"]][0] + 0.0)/(x_max - x_min)
    link['ty'] = (y_max - G.position[link["target"]][1] + 0.0)/(y_max - y_min)
    if link["target"] in nodes_to_hfs_network.group:
        link['hf'] = hf_2_group[nodes_to_hfs_network.group[link["target"]]]
    else:
        continue


# save both in node_link and adjacency_matrix format (see networkx for doc)
with open("hfs_network_node_link.json", "w") as nl_f:
    json.dump(nodes_to_hfs_network_data, nl_f)
    
nodes_to_hfs_network_data = json_graph.adjacency_data(nodes_to_hfs_network)

with open("hfs_network_adjacency_data.json", "w") as nl_f:
    json.dump(nodes_to_hfs_network_data, nl_f)    


# plot HFCA network; the networkx plot is limited; see README.txt for other visualization options  
print "Plotting HFCA network"
plot_hfca_network(nodes_to_hfs_network)
